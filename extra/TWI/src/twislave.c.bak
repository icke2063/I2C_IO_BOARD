#include <util/twi.h> 	    //enthält z.B. die Bezeichnungen für die Statuscodes in TWSR
#include <avr/interrupt.h>  //dient zur Behandlung der Interrupts
#include <stdint.h>         //definiert den Datentyp uint8_t
#include "twislave.h"

//icke2063
#include "eeprom_mapping.h"
#include <avr/eeprom.h>

//%%%%%%%% Globale Variablen, die vom Hauptprogramm genutzt werden %%%%%%%%
/*Der Buffer, in dem die Daten gespeichert werden.
Aus Sicht des Masters läuft der Zugrif auf den Buffer genau wie bei einem I2C-EEPROm ab.
Für den Slave ist es eine globale Variable
*/
volatile uint16_t buffer_adr; //"Adressregister" für den Buffer

volatile uint16_t slave_status; //Status für den Slave

/*Initaliserung des TWI-Inteface. Muss zu Beginn aufgerufen werden, sowie bei einem Wechsel der Slave Adresse
Parameter adr: gewünschte Slave-Adresse
*/
void init_twi_slave(uint8_t adr)
{

	DDRC &= ~((1<<4) | (1<<5));
	PORTC |= (1<<4) | (1<<5);


	//Adresse setzen um 1 bitshiften wegen TWAR register (siehe Datenblatt!)
	TWAR = (adr<<1) | (1<<TWGCE);
	TWCR = (1<<TWEN)|(1<<TWINT)|(1<<TWEA)|(1<<TWIE);


	//TWCR &= ~(1<<TWSTA)|(1<<TWSTO);
	//TWCR|= (1<<TWEA) | (1<<TWEN)|(1<<TWIE);

	//TWCR = (1<<TWEN)|(1<<TWINT)|(1<<TWEA)|(1<<TWIE);

	buffer_adr=0xFF;
	slave_status = ST_ADDR_INVALID;
	sei();

}


//Je nach Statuscode in TWSR müssen verschiedene Bitmuster in TWCR geschreiben werden(siehe Tabellen im Datenblatt!).
//Makros für die verwendeten Bitmuster:

//ACK nach empfangenen Daten senden/ ACK nach gesendeten Daten erwarten
//#define TWCR_ACK TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|(0<<TWWC);
#define TWCR_ACK TWCR=(1<<TWEN)|(1<<TWINT)|(1<<TWEA)|(1<<TWIE);

//NACK nach empfangenen Daten senden/ NACK nach gesendeten Daten erwarten
#define TWCR_NACK TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|(0<<TWWC);

//switch to the non adressed slave mode...
#define TWCR_RESET TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|(0<<TWWC);


/*ISR, die bei einem Ereignis auf dem Bus ausgelöst wird. Im Register TWSR befindet sich dann
ein Statuscode, anhand dessen die Situation festgestellt werden kann.
*/
ISR (TWI_vect)
{

uint8_t data=0;
switch (TW_STATUS) //TWI-Statusregister prüfen und nötige Aktion bestimmen
{

DDRD |= (1 << 6); //set DDR "1"
PORTD|= (1 << 6);

// Slave Receiver

case TW_SR_SLA_ACK: // 0x60 Slave Receiver, Slave wurde adressiert
	TWCR_ACK; // nächstes Datenbyte empfangen, ACK danach senden
	slave_status = ST_ADDR_INVALID;
break;

case TW_SR_DATA_ACK: // 0x80 Slave Receiver, ein Datenbyte wurde empfangen
	data=TWDR; //Empfangene Daten auslesen

	switch(slave_status){
	case ST_ADDR_INVALID://erster Zugriff, Bufferposition setzen
		#ifdef USE16BITADDRESS	//16Bit Modus -> set low Byte
			buffer_adr= data;
			slave_status = ST_WAITFORHIGH;		//Status setzen
			TWCR_ACK;		//Ack senden
			break;

		#else//8Bit Modus -> set low Byte (but thats all we need)
			//Kontrolle ob gewünschte Adresse im erlaubten bereich
			if(data<(I2C_BUFFER_SIZE+EEPROM_SIZE))
				{//address valid
					buffer_adr= data; //Bufferposition wie adressiert setzen
					slave_status = ST_ADDR_VALID;
					TWCR_ACK;		//Ack senden
					break;
				}
			else
				{//address invalid
					buffer_adr=0; //Adresse auf Null setzen. Ist das sinnvoll? TO DO!
					slave_status = ST_ADDR_INVALID;
					TWCR_NACK;		//Nack senden
					break;
				}
		#endif
		break;	//sollte nie erreicht werden
#ifdef USE16BITADDRESS
	case ST_WAITFORHIGH://zweiter Zugriff, HighByte Buffer setzten
		buffer_adr |= (data<<8); 				//low Byte Bufferposition setzen
		//Kontrolle ob gewünschte Adresse im erlaubten bereich
		if(buffer_adr>=(I2C_BUFFER_SIZE+EEPROM_SIZE))
			{
				buffer_adr=0; //Adresse auf Null setzen. Ist das sinnvoll? TO DO!
				slave_status = ST_ADDR_INVALID;
				TWCR_NACK;		//Nack senden
				break;
			}

		slave_status = ST_ADDR_VALID;
		TWCR_ACK;		//Ack senden

		break;
#endif
	case ST_ADDR_VALID:

		if(buffer_adr == 0){
			buffer_adr++; //Buffer-Adresse weiterzählen für nächsten Schreibzugriff
			TWCR_ACK;		//Ack senden
			break;
		}

		//write buffer data
		if(buffer_adr<I2C_BUFFER_SIZE)
		{
				i2cdata[buffer_adr]=data; //Daten in Buffer schreiben
				buffer_adr++; //Buffer-Adresse weiterzählen für nächsten Schreibzugriff
				TWCR_ACK;		//Ack senden
				break;
		}

		//write eeprom
		if(buffer_adr < (I2C_BUFFER_SIZE+EEPROM_SIZE))
		{
				eeprom_write_byte(buffer_adr-I2C_BUFFER_SIZE,data); //Daten in eeprom schreiben
				buffer_adr++; //Buffer-Adresse weiterzählen für nächsten Schreibzugriff
				TWCR_ACK;		//Ack senden
				break;
		}


	default://reset address
		slave_status = ST_ADDR_INVALID;
		TWCR_NACK;		//Nack senden
		break;
	}
break;


//Slave transmitter

case TW_ST_SLA_ACK: //0xA8 Slave wurde im Lesemodus adressiert und hat ein ACK zurückgegeben.
	//Hier steht kein break! Es wird also der folgende Code ebenfalls ausgeführt!

case TW_ST_DATA_ACK: //0xB8 Slave Transmitter, Daten wurden angefordert


	if(slave_status == ST_ADDR_INVALID){
		TWDR = 0;
		TWCR_NACK;
		break;
	}

	//read ram data
	if(buffer_adr<I2C_BUFFER_SIZE)
	{
			TWDR = i2cdata[buffer_adr]; //Daten lesen
			buffer_adr++; //Buffer-Adresse weiterzählen für nächsten Lesezugriff
			TWCR_ACK;		//Ack senden
			break;
	}

	//write eeprom
	if(buffer_adr<I2C_BUFFER_SIZE+EEPROM_SIZE)
	{
			TWDR = eeprom_read_byte(buffer_adr-I2C_BUFFER_SIZE); //Daten aus eeprom lesen
			buffer_adr++; //Buffer-Adresse weiterzählen für nächsten Schreibzugriff
			TWCR_ACK;		//Ack senden
			break;
	}

		TWDR=0; //Kein Daten mehr im Buffer
		TWCR_NACK;
break;

case TW_ST_DATA_NACK: // 0xC0 Keine Daten mehr gefordert
case TW_SR_DATA_NACK: // 0x88
case TW_ST_LAST_DATA: // 0xC8  Last data byte in TWDR has been transmitted (TWEA = “0”); ACK has been received
case TW_SR_STOP:      // 0xA0 STOP empfangen
default:
    TWCR_RESET;
break;

} //end.switch (TW_STATUS)
} //end.ISR(TWI_vect)

////Ende von twislave.c////
